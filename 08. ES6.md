# 1. ES6(Ecma Script 6)
## 1. const, let의 등장
1. var 변수는 중복 선언이 가능하고 블록 단위 변수가 아니며 호이스팅이 가능한 문제점이 존재하여 ES6부터는 let, const라는 변수 선언 방식이 등장했다.
2. 블록단위 변수 let
    - let은 중복선언 불가능하고 블록단위이며 호이스팅 불가능한 var의 대체 변수
3. 상수를 선언하는 const
    - const변수는 상수를 선언할 때 사용하여 선언과 동시에 초기화가 일어나야 한다.
    - const도 let과 동일하게 블록단위 변수이며 호이스팅 불가능
    - const는 상수이기 때문에 값의 재할당 불가능
    - 기본적으로 const로 변수를 선언하되 변경될 경우가 있는 변수만 let으로 선언한다.
4. const와 객체
    - const 변수로 객체를 선언하게 되면 객체안의 속성들은 변경할 수 있기 때문에 객체들은 모두 const로 선언한다.
    - 기본타입인 number, string ...은 const로 선언됐을 때 값을 변경할 수 없지만 객체나 배열의 요소들 또는 속성들은 변경 가능하다.
    - 자바스크립트에서 const는 재할당을 금지하는 것이고 불변을 의미하지는 않는다.

## 2. 템플릿 리터럴
1. 기존 ES5까지의 자바스크립트에서는 문자열을 선언할 때 작은따옴표('')나 큰따옴표("")를 사용했는 데 ES6버전에서 백틱(``)으로 만들 수 있는 문자열이 추가되었다.
2. 백틱(``)을 이용해서 문자열을 지정할 수 있으며 멀티라인 문자열, 표현식 삽입 등을 지원한다.
3. 표현식 삽입은 자바스크립트의 변수나 구문을 사용할 수 있는 것으로 ${}를 이용해서 표현식을 문자열 중간에 넣을 수 있다.

## 3. 지수연산자
1. 지수연산자는 거듭제곱을 연산해주는 연산자.
2. num1 ** num2
3. Math.pow()와 동일한 기능
4. 음수를 연산할 때는 음수를 소괄호()로 묶는다.


## 4. 논리연산자를 이용한 단축평가
1. &&나 || 연산시 연산의 결과가 true, false가 아닐 수도 있다.
2. &&나 || 연산 결과가 결정되는 시점의 값이 리턴되는 것을 단축평가라고 한다.
3. &&는 두 개 피연산자가 모두 true여야 true가 리턴되는데 true나 false가 첫 번째 피연산자가 true일 경우 결과가 결정되는 시점은 두번째 피연산자이다.
```
    true && 결과를 결정하는 시점
    'bit' && 'camp' => 'camp' 리턴(값이 있으면 true로 판단)

    false && 어떤값이 오든지 false => false 리턴 (연산의 결과가 나오는 시점을 정하는것. 단축평가.)

    false || 결과를 결정하는 시점
    false || 'bit' => 'bit' 리턴
    'camp' || 어떤값이 와도 true => 'camp' 리턴
```
4. 단축평가는 논리연산자(&&, ||)의 true, false를 결정하는 시점의 값을 리턴하는 것.

5.
```
true && 리턴값 => 리턴값이 리턴
false && 뭐가오든 상관없이 false => false리턴

true || 뭐가오든 상관없이 true => true 리턴
false || 리턴값 => 리턴값이 리턴
```


## 5. 객체에 추가된 기능들
1. 속성 축약표현
    - 기존에 ES5에서는 객체를 중괄호 블록으로 만들고 그 안에 속성을 키와 값으로 지정했다.
    ```
    var obj = {
        x: 1,
        y: 2
    };
    ```

    - ES6에서는 속성의 축약표현이라는 기능이 추가되었다.
    - 속성의 축약표현 변수를 선언하고 속성으로 그 변수를 넣어주면 변수명이 키로 자동할당되는 기능
    ```
    let x = 1;
    let y = 2;

    const obj = {x, y};
    ```

2. 계산된 프로퍼티 이름
    - 템플릿 리터럴의 표현식 삽입 기능을 이용해서 동적으로 속성키를 만들어주는 기능.
    - 기존 ES5에서는 속성키를 동적으로 생성하려면 []를 이용해서 문자열 결합연산자를 이용했는데 ES6에서는 템플릿 리터럴로 속성키와 값을 바로 매핑할 수 있다.
    ```
    // ES5 : 객체 안에 바로 못만들고 객체 밖에 아래처럼 만들어야함.
    var obj = {}; 
    var i = 0;

    obj['value_' + (++i)] = i;
    obj['value_' + (++i)] = i;
    obj['value_' + (++i)] = i;
    obj['value_' + (++i)] = i;

    // ES6
    let j = 0;
    const obj = {
        [`value_${++j}`]: j,
        [`value_${++j}`]: j,
        [`value_${++j}`]: j,
        [`value_${++j}`]: j
    };
    ```
3. 메소드 축약표현
    - ES5에서는 객체에 메소드를 추가할 때 키값과 function 키워드로 메소드를 추가했었는데 ES6에서는 function을 생략할 수 있다.