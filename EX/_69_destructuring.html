<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>비구조화 할당</title>
</head>
<body>
    <script>
        const arr = [31, 47, 80];

        // 매개변수를 비구조화 할당으로 선언
        const add = ([num1, num2, num3]) => {
            return num1 + num2 + num3;
        }

        const sum = add(arr);

        console.log(sum);

        // 비구조화 할당의 기준은 인덱스
        // 인덱스 기준으로 순서대로 할당되고 변수의 개수와 요소의 개수를 맞춰줄 필요는 없다.
        const minus = ([num1, num2]) => {
            return num1 - num2;
        }

        // 이 경우 80을 제외한 두 개의 숫자만 사용하게 된다.
        // 31, 47만 사용. 80은 사용하지 않음.
        const minu = minus(arr);
        console.log(minu);

        // Rest 파라미터와도 함께 사용 가능
        const arr2 = [12, 14, 2, 5, 24];

        const mul = ([num1, num2, ...rest]) => {
            console.log(rest); // rest는 따로 빼서 배열을 만들 수 있음.

            // reduce: 배열의 모든 요소를 순회하면서 지정된 콜백함수를 계속 호출. 콜백함수의 리턴 값을 다음 콜백함수 호출 시 첫번째 매개변수로 받아서 하나의 결과값을 만들어서 리턴.
            // const 변수 = 배열.reduce((이전콜백의 리턴값, 현재 꺼내온 변수, 인덱스) => 콜백함수);
            // const sum = arr.reduce((prior, current) => prior + current, 첫 번째 요소에 접근했을 때 이전 요소의 초기값);
            const num3 = rest.reduce((prior, current) => prior * current, 1);
            // console.log(num3);
            
            return num1 * num2 * num3;
        }

        console.log(mul(arr2));
    </script>
</body>
</html>